<?xml version="1.0" encoding="UTF-8"?>

<document>

  <properties>
    <author email="cservenak@is-micro.hu">CSERVENAK, Tamas</author>
    <title>ISmicro Projects</title>
  </properties>

  <meta name="keyword" content="ismicro java"/>

<body>

<section name="Developers guide">

<p>This Guide is <b>work in progress</b>.</p>

<subsection name="Pluggable proxying logic">

<p>The first thing would be to develop more complicated proxying logic aside three
"basic" ones provided in source. The logic should implement the following
inteface:</p>

<source>
public interface RepositoryLogic {
	
	/**
	 * Return true if repository should check for local cached version of the
	 * path.
	 * 
	 * @param path
	 * @return
	 */
	boolean shouldCheckForLocalCopy(String path);
	
	/**
	 * Postprocess item if needed after local copy found.
	 * 
	 * @param item
	 * @param repository
	 * @return
	 */
	ProxiedItem afterLocalCopyFound(ProxiedItem item, Repository repository);
	
	/**
	 * Return true if repository should initiate remote lookup.
	 * 
	 * @param path
	 * @param locallyExists true if there is a local copy found.
	 * @return
	 */
	boolean shouldCheckForRemoteCopy(String path, boolean locallyExists);
	
	/**
	 * Postprocess item if needed after remote retrieval.
	 * 
	 * @param item
	 * @param repository
	 * @return
	 */
	ProxiedItem afterRemoteCopyFound(ProxiedItem item, Repository repository);
	
	/**
	 * Return true if reposotiry should store the remote retrieved item in a 
	 * local writable store.
	 * 
	 * @param item
	 * @return
	 */
	boolean shouldStoreLocallyAfterRemoteRetrieval(ItemProperties item);

	/**
	 * Return true to index the given item.
	 * 
	 * @param item
	 * @return
	 */
	boolean shouldIndex(ItemProperties item);
	
}
</source>

<p>Let's see the "default" logic:</p>

<source>
public class DefaultProxyingLogic implements RepositoryLogic {

	protected Log logger = LogFactory.getLog(this.getClass());

	/**
	 * Always returns true.
	 */
	public boolean shouldCheckForLocalCopy(String path) {
		return true;
	}

	/**
	 * Does nothing and returns item unmodified.
	 */
	public ProxiedItem afterLocalCopyFound(ProxiedItem item, Repository repository) {
		return item;
	}

	/**
	 * Always returns !locallyExists. 
	 */
	public boolean shouldCheckForRemoteCopy(String path, boolean locallyExists) {
		return !locallyExists;
	}

	/**
	 * Does nothing and returns item unmodified.
	 */
	public ProxiedItem afterRemoteCopyFound(ProxiedItem item, Repository repository) {
		return item;
	}

	/**
	 * Always returns true.
	 */
	public boolean shouldStoreLocallyAfterRemoteRetrieval(ItemProperties item) {
		return true;
	}

	/**
	 * Always returns !item.isDirectory().
	 */
	public boolean shouldIndex(ItemProperties item) {
		return !item.isDirectory();
	}

}
</source>

<p>Look at the other existing implementations too.</p>

</subsection>

<subsection name="Access Control">

<p>You have possibility to provide Proximity level and per Repository access control.
You have to implement an AccessManager interface and inject it to Proximity or Repository bean.</p>

<p>AccessManager.java</p>

<source>
package hu.ismicro.commons.proximity.access;

import hu.ismicro.commons.proximity.AccessDeniedException;
import hu.ismicro.commons.proximity.ProximityRequest;

import java.util.Map;

/**
 * Interface for access manager.
 * 
 * @author t.cservenak
 *
 */
public interface AccessManager {
	
	/**
	 * The implementation of this method should throw AccessDeniedException or any
	 * subclass of that exception if it denies access.
	 * 
	 * @param grantee
	 * @param request
	 * @param config
	 * @throws AccessDeniedException
	 */
	void decide(Object grantee, ProximityRequest request, Map config) throws AccessDeniedException;

}
</source>

</subsection>

<subsection name="Other things to do">
<p>Practically, all elements of Proximity could be extended. Look for Remote Storages, Local
Storages, etc.</p>
</subsection>

</section>

</body>
</document>
